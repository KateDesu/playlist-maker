package com.practicum.playlistmaker.uiimport android.annotation.SuppressLintimport android.os.Bundleimport android.os.Handlerimport android.os.Looperimport android.text.Editableimport android.text.TextWatcherimport android.util.Logimport android.view.Viewimport android.view.inputmethod.InputMethodManagerimport android.widget.Buttonimport android.widget.EditTextimport android.widget.FrameLayoutimport android.widget.ImageViewimport android.widget.LinearLayoutimport android.widget.Toastimport androidx.activity.enableEdgeToEdgeimport androidx.appcompat.app.AppCompatActivityimport androidx.core.view.ViewCompatimport androidx.core.view.WindowInsetsCompatimport androidx.recyclerview.widget.LinearLayoutManagerimport androidx.recyclerview.widget.RecyclerViewimport com.google.android.material.appbar.MaterialToolbarimport com.practicum.playlistmaker.PLAYLISTMAKER_PREFERENCESimport com.practicum.playlistmaker.Rimport com.practicum.playlistmaker.data.TracksRepositoryImplimport com.practicum.playlistmaker.data.network.ITunesSearchApiimport com.practicum.playlistmaker.data.network.RetrofitNetworkClientimport com.practicum.playlistmaker.domain.api.TracksInteractorimport com.practicum.playlistmaker.domain.impl.TracksInteractorImplimport com.practicum.playlistmaker.domain.models.Trackimport com.practicum.playlistmaker.ui.tracks.TracksAdapterimport retrofit2.Retrofitimport retrofit2.converter.gson.GsonConverterFactoryconst val HISTORY_TRACKS_KEY = "history_tracks_key"class SearchActivity : AppCompatActivity() {    private var searchInput: String? = null    companion object {        private const val KEY_SEARCH_INPUT = "search_input"        private const val SEARCH_DEBOUNCE_DELAY = 2000L    }    private val handler = Handler(Looper.getMainLooper())    private val searchRunnable = Runnable { searchTracks() }    private fun searchDebounce() {        handler.removeCallbacks(searchRunnable)        handler.postDelayed(searchRunnable, SEARCH_DEBOUNCE_DELAY)    }    private val itunesBaseUrl = "https://itunes.apple.com/"    private val retrofit = Retrofit.Builder()        .baseUrl(itunesBaseUrl)        .addConverterFactory(GsonConverterFactory.create())        .build()    private val iTunesService = retrofit.create(ITunesSearchApi::class.java)    private lateinit var clearButton: ImageView    private lateinit var searchEditText: EditText    private lateinit var recyclerViewTracks: RecyclerView    private lateinit var viewHistoryTracks: LinearLayout    private lateinit var recyclerViewTracksHistory: RecyclerView    private lateinit var clearHistoryButton: Button    private lateinit var placeholderViewNoInternet: LinearLayout    private lateinit var placeholderViewNothingFound: LinearLayout    private lateinit var placeholderButton: Button    private lateinit var flProgressBar: FrameLayout    private val tracks = ArrayList<Track>()    private var tracksHistory = ArrayList<Track>()    private val tracksAdapter = TracksAdapter()    private val tracksHistoryAdapter = TracksAdapter()    @SuppressLint("NotifyDataSetChanged")    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        enableEdgeToEdge()        setContentView(R.layout.activity_search)        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.search)) { v, insets ->            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        }        val toolbar = findViewById<MaterialToolbar>(R.id.toolbar)        setSupportActionBar(toolbar)        // Включаем кнопку "Назад" в Toolbar        supportActionBar?.setDisplayHomeAsUpEnabled(true)        toolbar.setNavigationOnClickListener {            finish()        }        clearButton = findViewById(R.id.ivClearIcon)        searchEditText = findViewById(R.id.etSearch)        recyclerViewTracks = findViewById(R.id.rvTrackList)        placeholderViewNoInternet = findViewById(R.id.llPlaceholderNoInternet)        placeholderViewNothingFound = findViewById(R.id.llPlaceholderNothingFound)        placeholderButton = findViewById(R.id.btnUpdate)        recyclerViewTracksHistory = findViewById(R.id.rvTracksHistory)        viewHistoryTracks = findViewById(R.id.llTracksHistory)        clearHistoryButton = findViewById(R.id.btnClearHistory)        tracksAdapter.tracks = tracks        recyclerViewTracks.layoutManager =            LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)        recyclerViewTracks.adapter = tracksAdapter        flProgressBar = findViewById(R.id.flProgressBar)        searchEditText.addTextChangedListener(object : TextWatcher {            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {                clearButton.visibility = clearButtonVisibility(s)                searchInput = s.toString()                searchDebounce()            }            override fun afterTextChanged(s: Editable) {}        })        placeholderButton.setOnClickListener {            searchTracks()        }        clearButton.setOnClickListener {            searchEditText.setText("")            clearButton.setVisibility(View.GONE)            val imm = getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager            imm.hideSoftInputFromWindow(searchEditText.windowToken, 0)            tracks.clear()            tracksAdapter.notifyDataSetChanged()            showMessage("", "")        }        // реализация отображения / скрытия истории поиска        val sharedPrefs = getSharedPreferences(PLAYLISTMAKER_PREFERENCES, MODE_PRIVATE)        val searchHistory = SearchHistory(sharedPrefs)        tracksHistory = searchHistory.getTracksHistory()        tracksHistoryAdapter.tracks = tracksHistory        tracksHistoryAdapter.notifyDataSetChanged()        recyclerViewTracksHistory.layoutManager =            LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)        recyclerViewTracksHistory.adapter = tracksHistoryAdapter        searchEditText.addTextChangedListener(object : TextWatcher {            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {            }            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {                viewHistoryTracks.visibility =                    if (searchEditText.hasFocus() && s?.isEmpty() == true && tracksHistory.isNotEmpty()) View.VISIBLE else View.GONE                if (s?.isEmpty() == true) {                    // Обновляем список истории поиска                    tracksHistory = searchHistory.getTracksHistory()                    tracksHistoryAdapter.tracks = tracksHistory                    tracksHistoryAdapter.notifyDataSetChanged()                }            }            override fun afterTextChanged(s: Editable?) {            }        })        searchEditText.setOnFocusChangeListener { _, hasFocus ->            viewHistoryTracks.visibility =                if (hasFocus && searchEditText.text.isEmpty() && tracksHistory.isNotEmpty()) View.VISIBLE else View.GONE        }        // очистка истории поиска        clearHistoryButton.setOnClickListener {            searchHistory.clearHistory()            tracksHistory.clear()            Log.d("MyAdapter", "2 Список данных обновлен перед вызовом notifyDataSetChanged()")            tracksHistoryAdapter.notifyDataSetChanged()            viewHistoryTracks.visibility = View.GONE        }    }    private fun searchTracks() {        flProgressBar.visibility = View.VISIBLE        placeholderViewNoInternet.visibility = View.GONE        placeholderViewNothingFound.visibility = View.GONE        val networkClient = RetrofitNetworkClient()        val repository = TracksRepositoryImpl(networkClient)        val tracksInteractor = TracksInteractorImpl(repository)        tracksInteractor.searchTracks(searchEditText.text.toString(), object : TracksInteractor.TracksConsumer {            @SuppressLint("NotifyDataSetChanged")            override fun consume(foundTracks: List<Track>) {                flProgressBar.visibility = View.GONE                tracks.clear()                if (foundTracks.isNotEmpty()) {                    tracks.addAll(foundTracks)                    tracksAdapter.notifyDataSetChanged()                    placeholderViewNothingFound.visibility = View.GONE                    showMessage("", "")                } else {                    placeholderViewNothingFound.visibility = View.VISIBLE                    showMessage(getString(R.string.nothing_found), "")                }            }        })    }    private fun clearButtonVisibility(s: CharSequence?): Int {        return if (s.isNullOrEmpty()) {            View.GONE        } else {            View.VISIBLE        }    }    override fun onSaveInstanceState(outState: Bundle) {        super.onSaveInstanceState(outState)        outState.putString(KEY_SEARCH_INPUT, searchInput)    }    override fun onRestoreInstanceState(savedInstanceState: Bundle) {        super.onRestoreInstanceState(savedInstanceState)        searchInput = savedInstanceState.getString(KEY_SEARCH_INPUT)    }    @SuppressLint("NotifyDataSetChanged")    private fun showMessage(text: String, additionalMessage: String) {        if (text.isNotEmpty()) {            tracks.clear()            Log.d(                "MyAdapter",                "4 Список данных tracksAdapter обновлен перед вызовом notifyDataSetChanged()"            )            tracksAdapter.notifyDataSetChanged()            if (additionalMessage.isNotEmpty()) {                Toast.makeText(applicationContext, additionalMessage, Toast.LENGTH_LONG)                    .show()            }        } else {            placeholderViewNoInternet.visibility = View.GONE            placeholderViewNothingFound.visibility = View.GONE        }    }}