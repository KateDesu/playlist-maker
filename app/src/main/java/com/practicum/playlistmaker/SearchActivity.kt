package com.practicum.playlistmakerimport android.annotation.SuppressLintimport android.content.Intentimport android.os.Bundleimport android.text.Editableimport android.text.TextWatcherimport android.util.Logimport android.view.Viewimport android.view.inputmethod.EditorInfoimport android.view.inputmethod.InputMethodManagerimport android.widget.Buttonimport android.widget.EditTextimport android.widget.ImageViewimport android.widget.LinearLayoutimport android.widget.Toastimport androidx.activity.enableEdgeToEdgeimport androidx.appcompat.app.AppCompatActivityimport androidx.core.view.ViewCompatimport androidx.core.view.WindowInsetsCompatimport androidx.recyclerview.widget.LinearLayoutManagerimport androidx.recyclerview.widget.RecyclerViewimport com.google.android.material.appbar.MaterialToolbarimport retrofit2.Callimport retrofit2.Callbackimport retrofit2.Responseimport retrofit2.Retrofitimport retrofit2.converter.gson.GsonConverterFactoryconst val HISTORY_TRACKS_KEY = "history_tracks_key"class SearchActivity : AppCompatActivity() {    private var searchInput: String? = null    companion object {        private const val KEY_SEARCH_INPUT = "search_input"    }    private val itunesBaseUrl = "https://itunes.apple.com/"    private val retrofit = Retrofit.Builder()        .baseUrl(itunesBaseUrl)        .addConverterFactory(GsonConverterFactory.create())        .build()    private val iTunesService = retrofit.create(ITunesSearchApi::class.java)    private lateinit var clearButton: ImageView    private lateinit var searchEditText: EditText    private lateinit var recyclerViewTracks: RecyclerView    private lateinit var viewHistoryTracks: LinearLayout    private lateinit var recyclerViewTracksHistory: RecyclerView    private lateinit var clearHistoryButton: Button    private lateinit var placeholderViewNoInternet: LinearLayout    private lateinit var placeholderViewNothingFound: LinearLayout    private lateinit var placeholderButton: Button    private val tracks = ArrayList<Track>()    private var tracksHistory = ArrayList<Track>()    private val tracksAdapter = TracksAdapter()    private val tracksHistoryAdapter = TracksAdapter()    @SuppressLint("NotifyDataSetChanged")    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        enableEdgeToEdge()        setContentView(R.layout.activity_search)        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.search)) { v, insets ->            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        }        val toolbar = findViewById<MaterialToolbar>(R.id.toolbar)        setSupportActionBar(toolbar)        // Включаем кнопку "Назад" в Toolbar        supportActionBar?.setDisplayHomeAsUpEnabled(true)        toolbar.setNavigationOnClickListener {            val toolbarIntent = Intent(this, MainActivity::class.java)            startActivity(toolbarIntent)        }        clearButton = findViewById(R.id.ivClearIcon)        searchEditText = findViewById(R.id.etSearch)        recyclerViewTracks = findViewById(R.id.rvTrackList)        placeholderViewNoInternet = findViewById(R.id.llPlaceholderNoInternet)        placeholderViewNothingFound = findViewById(R.id.llPlaceholderNothingFound)        placeholderButton = findViewById(R.id.btnUpdate)        recyclerViewTracksHistory = findViewById(R.id.rvTracksHistory)        viewHistoryTracks = findViewById(R.id.llTracksHistory)        clearHistoryButton = findViewById(R.id.btnClearHistory)        tracksAdapter.tracks = tracks        recyclerViewTracks.layoutManager =            LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)        recyclerViewTracks.adapter = tracksAdapter        searchEditText.addTextChangedListener(object : TextWatcher {            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {                clearButton.visibility = clearButtonVisibility(s)                searchInput = s.toString()            }            override fun afterTextChanged(s: Editable) {}        })        searchEditText.setOnEditorActionListener { _, actionId, _ ->            if (actionId == EditorInfo.IME_ACTION_DONE) {                searchTracks()            }            false        }        placeholderButton.setOnClickListener {            searchTracks()        }        clearButton.setOnClickListener {            searchEditText.setText("")            clearButton.setVisibility(View.GONE)            val imm = getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager            imm.hideSoftInputFromWindow(searchEditText.windowToken, 0)            tracks.clear()            tracksAdapter.notifyDataSetChanged()            showMessage("", "")        }        // реализация отображения / скрытия истории поиска        val sharedPrefs = getSharedPreferences(PLAYLISTMAKER_PREFERENCES, MODE_PRIVATE)        val searchHistory = SearchHistory(sharedPrefs)        tracksHistory = searchHistory.getTracksHistory()        tracksHistoryAdapter.tracks=tracksHistory        Log.d("MyAdapter", "1 Список данных обновлен перед вызовом notifyDataSetChanged()")        tracksHistoryAdapter.notifyDataSetChanged()        recyclerViewTracksHistory.layoutManager =            LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)        recyclerViewTracksHistory.adapter = tracksHistoryAdapter        searchEditText.addTextChangedListener(object : TextWatcher {            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {            }            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {                viewHistoryTracks.visibility = if (searchEditText.hasFocus() && s?.isEmpty() == true && tracksHistory.isNotEmpty()) View.VISIBLE else View.GONE                if (s?.isEmpty() == true) {                    // Обновляем список истории поиска                    tracksHistory = searchHistory.getTracksHistory()                    tracksHistoryAdapter.tracks = tracksHistory                    Log.d("MyAdapter", "5 Список данных обновлен перед вызовом notifyDataSetChanged()")                    tracksHistoryAdapter.notifyDataSetChanged()                }            }            override fun afterTextChanged(s: Editable?) {            }        })        searchEditText.setOnFocusChangeListener { _, hasFocus ->            viewHistoryTracks.visibility = if (hasFocus && searchEditText.text.isEmpty() && tracksHistory.isNotEmpty()) View.VISIBLE else View.GONE        }        // очистка истории поиска        clearHistoryButton.setOnClickListener {            searchHistory.clearHistory()            tracksHistory.clear()            Log.d("MyAdapter", "2 Список данных обновлен перед вызовом notifyDataSetChanged()")            tracksHistoryAdapter.notifyDataSetChanged()            viewHistoryTracks.visibility = View.GONE        }    }    private fun searchTracks() {        iTunesService.search(searchEditText.text.toString())            .enqueue(object : Callback<TracksResponse> {                @SuppressLint("NotifyDataSetChanged")                override fun onResponse(                    call: Call<TracksResponse>,                    response: Response<TracksResponse>                ) {                    if (response.code() == 200) {                        tracks.clear()                        if (response.body()?.results?.isNotEmpty() == true) {                            tracks.addAll(response.body()?.results!!)                            Log.d("MyAdapter", "3 Список данных tracksAdapter обновлен перед вызовом notifyDataSetChanged()")                            tracksAdapter.notifyDataSetChanged()                        }                        if (tracks.isEmpty()) {                            Log.d("Nothing", "R.string.nothing_found")                            placeholderViewNothingFound.visibility = View.VISIBLE                            showMessage(getString(R.string.nothing_found), "")                        } else {                            Log.d("Nothing", "Allright")                            showMessage("", "")                        }                    } else {                        Log.d("Nothing", response.code().toString())                    }                }                override fun onFailure(call: Call<TracksResponse>, t: Throwable) {                    Log.d("Nothing", t.message.toString())                    placeholderViewNoInternet.visibility = View.VISIBLE                    showMessage(getString(R.string.nothing_found), t.message.toString())                }            })    }    private fun clearButtonVisibility(s: CharSequence?): Int {        return if (s.isNullOrEmpty()) {            View.GONE        } else {            View.VISIBLE        }    }    override fun onSaveInstanceState(outState: Bundle) {        super.onSaveInstanceState(outState)        outState.putString(KEY_SEARCH_INPUT, searchInput)    }    override fun onRestoreInstanceState(savedInstanceState: Bundle) {        super.onRestoreInstanceState(savedInstanceState)        searchInput = savedInstanceState.getString(KEY_SEARCH_INPUT)    }    @SuppressLint("NotifyDataSetChanged")    private fun showMessage(text: String, additionalMessage: String) {        if (text.isNotEmpty()) {            tracks.clear()            Log.d("MyAdapter", "4 Список данных tracksAdapter обновлен перед вызовом notifyDataSetChanged()")            tracksAdapter.notifyDataSetChanged()            if (additionalMessage.isNotEmpty()) {                Toast.makeText(applicationContext, additionalMessage, Toast.LENGTH_LONG)                    .show()            }        } else {            placeholderViewNoInternet.visibility = View.GONE            placeholderViewNothingFound.visibility = View.GONE        }    }}