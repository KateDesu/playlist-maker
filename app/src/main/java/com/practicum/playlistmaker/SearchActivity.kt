package com.practicum.playlistmakerimport android.content.Intentimport android.os.Bundleimport android.text.Editableimport android.text.TextWatcherimport android.util.Logimport android.view.Viewimport android.view.inputmethod.EditorInfoimport android.view.inputmethod.InputMethodManagerimport android.widget.Buttonimport android.widget.EditTextimport android.widget.FrameLayoutimport android.widget.ImageViewimport android.widget.LinearLayoutimport android.widget.TextViewimport android.widget.Toastimport androidx.activity.enableEdgeToEdgeimport androidx.appcompat.app.AppCompatActivityimport androidx.core.view.ViewCompatimport androidx.core.view.WindowInsetsCompatimport androidx.recyclerview.widget.LinearLayoutManagerimport androidx.recyclerview.widget.RecyclerViewimport com.google.android.material.appbar.MaterialToolbarimport retrofit2.Callimport retrofit2.Callbackimport retrofit2.Responseimport retrofit2.Retrofitimport retrofit2.converter.gson.GsonConverterFactoryclass SearchActivity : AppCompatActivity() {    private var search_input: String? = null    companion object {        private const val KEY_SEARCH_INPUT = "search_input"    }    private val itunesBaseUrl = "https://itunes.apple.com/";    private val retrofit = Retrofit.Builder()        .baseUrl(itunesBaseUrl)        .addConverterFactory(GsonConverterFactory.create())        .build()    private val iTunesService = retrofit.create(ITunesSearchApi::class.java)    private lateinit var clearButton: ImageView    private lateinit var searchEditText: EditText    private lateinit var recyclerViewTracks: RecyclerView    private lateinit var placeholderView: LinearLayout    private lateinit var placeholderMessage: TextView    private lateinit var placeholderImage: ImageView    private lateinit var placeholderButton: Button    private val tracks = ArrayList<Track>()    private val tracksAdapter = TracksAdapter()    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        enableEdgeToEdge()        setContentView(R.layout.activity_search)        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.search)) { v, insets ->            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)            insets        }        val toolbar = findViewById<MaterialToolbar>(R.id.toolbar)        setSupportActionBar(toolbar)        // Включаем кнопку "Назад" в Toolbar        supportActionBar?.setDisplayHomeAsUpEnabled(true)        toolbar.setNavigationOnClickListener {            val toolbarIntent = Intent(this, MainActivity::class.java)            startActivity(toolbarIntent)        }        clearButton = findViewById(R.id.ivClearIcon)        searchEditText = findViewById(R.id.etSearch)        recyclerViewTracks = findViewById(R.id.rvTrackList)        placeholderView = findViewById(R.id.llPlaceholder)        placeholderMessage = findViewById(R.id.etPlaceholderMessage)        placeholderImage = findViewById(R.id.ivSearchError)        placeholderButton = findViewById(R.id.btnPlaceholderUpdate)        tracksAdapter.tracks = tracks        recyclerViewTracks.layoutManager =            LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)        recyclerViewTracks.adapter = tracksAdapter        searchEditText.addTextChangedListener(object : TextWatcher {            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {                clearButton.visibility = clearButtonVisibility(s)                search_input = s.toString()            }            override fun afterTextChanged(s: Editable) {}        })        searchEditText.setOnEditorActionListener { _, actionId, _ ->            if (actionId == EditorInfo.IME_ACTION_DONE) {                iTunesService.search(searchEditText.text.toString())                    .enqueue(object : Callback<TracksResponse> {                        override fun onResponse(                            call: Call<TracksResponse>,                            response: Response<TracksResponse>                        ) {                            if (response.code() == 200) {                                tracks.clear()                                if (response.body()?.results?.isNotEmpty() == true) {                                    tracks.addAll(response.body()?.results!!)                                    tracksAdapter.notifyDataSetChanged()                                }                                if (tracks.isEmpty()) {                                    Log.d("Nothing", "R.string.nothing_found")                                    placeholderImage.setImageResource(R.drawable.placeholder_nothing_found)                                    showMessage(getString(R.string.nothing_found), "")                                } else {                                    Log.d("Nothing", "Allright")                                    showMessage("", "")                                }                            } else {                                Log.d("Nothing", response.code().toString())                            }                        }                        override fun onFailure(call: Call<TracksResponse>, t: Throwable) {                            Log.d("Nothing", t.message.toString())                            placeholderImage.setImageResource(R.drawable.placeholder_no_internet)                            showMessage(getString(R.string.something_went_wrong), t.message.toString())                            placeholderButton.visibility=View.VISIBLE                        }                    })                true            }            false        }        clearButton.setOnClickListener {            searchEditText.setText("");            clearButton.setVisibility(View.GONE);            val imm = getSystemService(INPUT_METHOD_SERVICE) as InputMethodManager            imm.hideSoftInputFromWindow(searchEditText.windowToken, 0)            placeholderView.visibility=View.GONE        }    }    private fun clearButtonVisibility(s: CharSequence?): Int {        return if (s.isNullOrEmpty()) {            View.GONE        } else {            View.VISIBLE        }    }    override fun onSaveInstanceState(outState: Bundle) {        super.onSaveInstanceState(outState)        outState.putString(KEY_SEARCH_INPUT, search_input)    }    override fun onRestoreInstanceState(savedInstanceState: Bundle) {        super.onRestoreInstanceState(savedInstanceState)        search_input = savedInstanceState.getString(KEY_SEARCH_INPUT)    }    private fun showMessage(text: String, additionalMessage: String) {        if (text.isNotEmpty()) {            placeholderView.visibility=View.VISIBLE            tracks.clear()            tracksAdapter.notifyDataSetChanged()            placeholderMessage.text = text            if (additionalMessage.isNotEmpty()) {                Toast.makeText(applicationContext, additionalMessage, Toast.LENGTH_LONG)                    .show()            }        } else {            placeholderView.visibility=View.GONE            placeholderButton.visibility=View.GONE        }    }}